---
title: "CS-118-02 Week 10"
author: "Varun Narravula"
date: 2022-04-04
---

**You can follow along with the examples provided in the folders. I use Nix, and
got a bit lazy when uploading, so you can look at instructions to build in the
buildPhase portions of those files and ignore everything else.**

## Shift vs. Rotate

You've done bitwise shifts before in C and C++ using `<<` and `>>`. In assembly,
their equivalents are `shl` (_shift left_) and `shr` (_shift right_). `rax >> 1`
If you want to perform the equivalent of `$ax << 2` in assembly, you would write
`shl ax, 2`; if you wanted to shift right by 2, then you do `shr ax, 2`.

However, what about rotating? Rotating is a bit like shifting, except that if
any values go off the sides on a shift, they will be wrapped onto the other
side. If you rotate a number `0b00001011` right by 1, then it would result in
`0b10000101`, where the 1 that got shifted got put back on the other side
instead of getting discarded.

Another instruction that looks similar to the normal shifts is `sal` (_shift
arithmetic right_) and `sar` (_shift arithmetic left_). What does this do?
Normal shift instructions only work on unsigned values, and overflow/underflow
otherwise. Arithmetic shifts like these will make sure to preserve the sign.

Let's look at some code to see why this can be useful.

```asm
_start:
    mov ax, -1
    shl ax, 1

```

## Test vs Cmp

There is another instruction called `test`, which works similarly to `cmp`.
However, it performs a bitwise `and` (i.e. `test eax, eax` would compute
`and eax, eax`) instead of subtracting (i.e. `cmp, eax, 0` would compute
`sub eax, 0`) and set flags depending on the result. You can use this to compare
as well.

## Intrinsics

What are intrinsics? You already know how SSE can make things much more
efficient because it is a SIMD instruction set. However, it's extremely
difficult to do this using assembly; most people use intrinsics instead. It is
the same instruction set, but it uses C, which is much easier than assembly
because of the access to much more robust C tooling. Intel provides an SDK that
interfaces with SSE instructions and looks very similar to actual assembly code;
all you need to do is include a single header. There is no need to deal with
compliated compile instructions anymore; all you need is a C compiler.

Every SSE instruction has a corresponding C function that is described on
Intel's website with comprehensive documentation on what parameters it takes,
what architectures and microcode and chipsets it is supported by, and other
things.

-- Talk about how to use intrinsics here and how to reference documentation. --

## Averages and Standard Deviation

A standard deviatino, if you do not know what it is from statistics, is a description
of the amount of difference from an average for a given dataset.

This isn't a math class, what does this have to do with assembly?
Using a load_reverse operation

-- Get standard deviation using intrinsicts. --
**
loop
**

## Division

What about division?
